-- =====================================================
-- MIGRATION 004: PREVENT DUPLICATE INVITES AND MEMBERSHIPS
-- =====================================================
-- Purpose: Add validation to prevent:
--   1. Self-invitations
--   2. Inviting existing staff members
--   3. Owners accepting manager invites
--   4. Duplicate memberships in the same clinic
-- =====================================================

-- =====================================================
-- 1. UPDATE accept_staff_invite RPC WITH VALIDATION
-- =====================================================

CREATE OR REPLACE FUNCTION accept_staff_invite(p_token TEXT, p_user_id UUID)
RETURNS JSONB AS $$
DECLARE
    inv RECORD;
    user_email TEXT;
    existing_owner RECORD;
    existing_staff RECORD;
BEGIN
    -- Get invite details
    SELECT * INTO inv
    FROM public.staff_invites
    WHERE token = p_token
      AND expires_at > NOW()
      AND accepted_at IS NULL;

    IF inv IS NULL THEN
        RAISE EXCEPTION 'Invalid or expired invite token';
    END IF;

    -- Get user's email
    SELECT email INTO user_email
    FROM auth.users
    WHERE id = p_user_id;

    -- Verify email matches invite
    IF lower(user_email) != lower(inv.email) THEN
        RAISE EXCEPTION 'Email mismatch: invite is for %, but user email is %', inv.email, user_email;
    END IF;

    -- Check 1: Is user already an owner of another clinic?
    SELECT sm.role, c.name as clinic_name INTO existing_owner
    FROM public.staff_members sm
    JOIN public.clinic c ON c.id = sm.clinic_id
    WHERE sm.user_id = p_user_id
      AND sm.role = 'owner'
    LIMIT 1;

    IF existing_owner IS NOT NULL THEN
        RAISE EXCEPTION 'You are already an owner of "%". Clinic owners cannot join other clinics as managers.', existing_owner.clinic_name;
    END IF;

    -- Check 2: Is user already a staff member in THIS clinic?
    SELECT role, status INTO existing_staff
    FROM public.staff_members
    WHERE user_id = p_user_id
      AND clinic_id = inv.clinic_id;

    IF existing_staff IS NOT NULL THEN
        RAISE EXCEPTION 'You are already a % in this clinic (Status: %)', existing_staff.role, existing_staff.status;
    END IF;

    -- All checks passed - Create staff membership
    INSERT INTO public.staff_members (clinic_id, user_id, role, staff_id, status, invited_by)
    VALUES (
        inv.clinic_id, 
        p_user_id, 
        inv.role, 
        '', -- Auto-generated by trigger
        'active',
        inv.invited_by
    );

    -- Mark invite as accepted
    UPDATE public.staff_invites
    SET accepted_at = NOW()
    WHERE id = inv.id;

    -- Return success with clinic info
    RETURN jsonb_build_object(
        'success', true,
        'clinic_id', inv.clinic_id,
        'role', inv.role
    );
EXCEPTION
    WHEN OTHERS THEN
        RETURN jsonb_build_object(
            'success', false,
            'error', SQLERRM
        );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- =====================================================
-- 2. ADD UNIQUE CONSTRAINT ON STAFF_MEMBERS
-- =====================================================
-- Prevent duplicate user-clinic combinations at database level

-- Drop constraint if it exists (for re-running migration)
ALTER TABLE public.staff_members 
DROP CONSTRAINT IF EXISTS unique_user_per_clinic;

-- Add unique constraint
ALTER TABLE public.staff_members 
ADD CONSTRAINT unique_user_per_clinic 
UNIQUE (user_id, clinic_id);

-- Add index for performance
CREATE INDEX IF NOT EXISTS idx_staff_members_user_clinic 
ON public.staff_members(user_id, clinic_id);

-- =====================================================
-- 3. ADD CHECK CONSTRAINT TO PREVENT OWNER DUPLICATES
-- =====================================================
-- Ensure users can only be owner of ONE clinic

-- Create function to check owner count
CREATE OR REPLACE FUNCTION check_single_owner()
RETURNS TRIGGER AS $$
DECLARE
    owner_count INTEGER;
BEGIN
    -- Only check if role is 'owner'
    IF NEW.role = 'owner' THEN
        -- Count existing owner roles for this user
        SELECT COUNT(*) INTO owner_count
        FROM public.staff_members
        WHERE user_id = NEW.user_id
          AND role = 'owner'
          AND id != COALESCE(NEW.id, '00000000-0000-0000-0000-000000000000'::uuid);
        
        IF owner_count > 0 THEN
            RAISE EXCEPTION 'User can only be an owner of one clinic';
        END IF;
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Drop trigger if exists
DROP TRIGGER IF EXISTS enforce_single_owner ON public.staff_members;

-- Create trigger
CREATE TRIGGER enforce_single_owner
    BEFORE INSERT OR UPDATE ON public.staff_members
    FOR EACH ROW
    EXECUTE FUNCTION check_single_owner();

-- =====================================================
-- 4. ADD UNIQUE CONSTRAINT ON PENDING INVITES
-- =====================================================
-- Prevent multiple active invites for the same email in a clinic

-- Create unique partial index for pending invites
DROP INDEX IF EXISTS idx_unique_pending_invite;

CREATE UNIQUE INDEX idx_unique_pending_invite 
ON public.staff_invites(clinic_id, LOWER(email))
WHERE accepted_at IS NULL AND expires_at > NOW();

-- =====================================================
-- 5. ADD FUNCTION TO CHECK IF EMAIL CAN BE INVITED
-- =====================================================
-- Helper function for checking if an email is eligible for invitation

CREATE OR REPLACE FUNCTION can_invite_email(
    p_clinic_id UUID,
    p_email TEXT,
    p_inviter_id UUID
)
RETURNS JSONB AS $$
DECLARE
    inviter_profile RECORD;
    existing_user RECORD;
    existing_staff RECORD;
    pending_invite RECORD;
BEGIN
    -- Get inviter's email
    SELECT email INTO inviter_profile
    FROM auth.users
    WHERE id = p_inviter_id;

    -- Check 1: Can't invite yourself
    IF lower(inviter_profile.email) = lower(p_email) THEN
        RETURN jsonb_build_object(
            'can_invite', false,
            'reason', 'You cannot invite yourself'
        );
    END IF;

    -- Check 2: Check if email belongs to registered user
    SELECT id INTO existing_user
    FROM auth.users
    WHERE lower(email) = lower(p_email);

    IF existing_user IS NOT NULL THEN
        -- Check if user is already in this clinic
        SELECT role, status INTO existing_staff
        FROM public.staff_members
        WHERE user_id = existing_user.id
          AND clinic_id = p_clinic_id;

        IF existing_staff IS NOT NULL THEN
            IF existing_staff.status = 'active' THEN
                RETURN jsonb_build_object(
                    'can_invite', false,
                    'reason', format('This user is already an active %s in your clinic', existing_staff.role)
                );
            ELSE
                RETURN jsonb_build_object(
                    'can_invite', false,
                    'reason', format('This user is already in your clinic but %s. Please activate them instead.', existing_staff.status)
                );
            END IF;
        END IF;

        -- Check if user is an owner of another clinic
        SELECT COUNT(*) > 0 INTO existing_staff
        FROM public.staff_members
        WHERE user_id = existing_user.id
          AND role = 'owner';

        IF existing_staff THEN
            RETURN jsonb_build_object(
                'can_invite', false,
                'reason', 'This user is already a clinic owner and cannot be invited as a manager'
            );
        END IF;
    END IF;

    -- Check 3: Check for pending invites
    SELECT expires_at INTO pending_invite
    FROM public.staff_invites
    WHERE clinic_id = p_clinic_id
      AND lower(email) = lower(p_email)
      AND accepted_at IS NULL
      AND expires_at > NOW();

    IF pending_invite IS NOT NULL THEN
        RETURN jsonb_build_object(
            'can_invite', false,
            'reason', 'An active invitation already exists for this email'
        );
    END IF;

    -- All checks passed
    RETURN jsonb_build_object(
        'can_invite', true,
        'reason', NULL
    );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Grant execute permission
GRANT EXECUTE ON FUNCTION can_invite_email(UUID, TEXT, UUID) TO authenticated;

-- =====================================================
-- 6. VERIFICATION & COMPLETION
-- =====================================================
DO $$
BEGIN
    RAISE NOTICE '✅ Migration 004 Complete: Duplicate Invite Prevention';
    RAISE NOTICE '';
    RAISE NOTICE 'Added protections:';
    RAISE NOTICE '   ✅ Unique constraint: One user per clinic';
    RAISE NOTICE '   ✅ Trigger: Users can only own one clinic';
    RAISE NOTICE '   ✅ Index: Prevent duplicate pending invites';
    RAISE NOTICE '   ✅ Updated RPC: Enhanced validation in accept_staff_invite';
    RAISE NOTICE '   ✅ New RPC: can_invite_email for pre-validation';
    RAISE NOTICE '';
    RAISE NOTICE 'Validations enforced:';
    RAISE NOTICE '   - Cannot invite yourself';
    RAISE NOTICE '   - Cannot invite existing staff members';
    RAISE NOTICE '   - Clinic owners cannot join as managers';
    RAISE NOTICE '   - One active invite per email per clinic';
    RAISE NOTICE '   - One owner role per user globally';
    RAISE NOTICE '';
END $$;
